# Arduino 钢琴传感器规则测试文档

## 配置参数总览

### 硬件映射
- **A0-A5** → 输出编号 **1-6**
- **D3** → 输出编号 **7**

### 关键参数
```cpp
analogThreshold = 190           // 模拟输入触发阈值
globalDebounceDelay = 1000ms    // 全局去抖延迟
d3DebounceDelay = 3500ms        // D3专用去抖延迟
touchStableThreshold = 10       // D3状态稳定次数
numReadings = 5                 // 移动平均滤波样本数
enableD3 = true                 // D3启用状态
```

---

## 测试场景

### 测试1: 模拟输入基本触发
**目标**: 验证A0-A5能正确触发并输出1-6

**步骤**:
1. 依次触摸连接到A0-A5的传感器
2. 观察串口输出

**预期结果**:
- A0触发 → 输出 `1`
- A1触发 → 输出 `2`
- A2触发 → 输出 `3`
- A3触发 → 输出 `4`
- A4触发 → 输出 `5`
- A5触发 → 输出 `6`

**规则验证**:
- ✓ 变化量必须 > 190
- ✓ 使用5次读数移动平均平滑

---

### 测试2: 全局去抖延迟（1000ms）
**目标**: 验证模拟输入的1秒去抖机制

**步骤**:
1. 触发任意模拟输入（如A0）
2. 立即（<1秒内）触发另一个输入（如A1）
3. 等待1秒后再次触发A1

**预期结果**:
- 第1次触发A0 → 输出 `1` ✓
- 立即触发A1 → **无输出** ✗（被全局锁定）
- 1秒后触发A1 → 输出 `2` ✓

**规则验证**:
- ✓ `globalDebounceDelay = 1000ms` 生效
- ✓ 全局互斥锁定工作正常

---

### 测试3: D3触摸检测
**目标**: 验证D3的LOW→HIGH跳变检测

**步骤**:
1. 触摸D3传感器（使其从LOW变为HIGH）
2. 观察串口输出

**预期结果**:
- D3触发 → 输出 `7`

**规则验证**:
- ✓ 检测LOW→HIGH跳变
- ✓ 需要连续10次检测到HIGH才确认（稳定性）
- ✓ 触发后更新全局锁定时间

---

### 测试4: D3专用去抖延迟（3500ms）
**目标**: 验证D3的3.5秒去抖机制

**步骤**:
1. 触发D3
2. 立即（<3.5秒内）再次触发D3
3. 等待3.5秒后再次触发D3

**预期结果**:
- 第1次触发 → 输出 `7` ✓
- 3.5秒内再触发 → **无输出** ✗
- 3.5秒后触发 → 输出 `7` ✓

**规则验证**:
- ✓ `d3DebounceDelay = 3500ms` 生效
- ✓ D3使用独立的延迟时间（不是1000ms）

---

### 测试5: D3状态稳定性检测
**目标**: 验证10次连续检测机制

**步骤**:
1. 快速点触D3（不足10次循环）
2. 持续触摸D3（超过10次循环）

**预期结果**:
- 快速点触 → **无输出** ✗（未达到10次）
- 持续触摸 → 输出 `7` ✓（达到10次稳定）

**规则验证**:
- ✓ `touchStableThreshold = 10` 生效
- ✓ 防止误触发

---

### 测试6: 全局互斥锁定
**目标**: 验证同一时刻只能有一个引脚触发

**步骤**:
1. 同时触摸多个传感器（如A0和A1）
2. 观察哪个先触发

**预期结果**:
- 只有一个引脚输出编号
- 另一个被全局锁定阻止（1秒内）

**规则验证**:
- ✓ `globalLastTriggerTime` 全局锁定生效
- ✓ 确保不会同时触发多个输出

---

### 测试7: D3与模拟输入互斥
**目标**: 验证D3触发会影响模拟输入的全局锁定

**步骤**:
1. 触发D3
2. 立即（<1秒内）触发A0

**预期结果**:
- D3触发 → 输出 `7` ✓
- A0立即触发 → **无输出** ✗（被D3的全局锁定阻止）

**规则验证**:
- ✓ D3触发更新 `globalLastTriggerTime`
- ✓ 模拟输入检查全局锁定时间

---

### 测试8: 阈值边界测试
**目标**: 验证190阈值的准确性

**步骤**:
1. 轻触传感器（变化量<190）
2. 用力触摸（变化量>190）

**预期结果**:
- 轻触 → **无输出** ✗
- 用力触摸 → 输出对应编号 ✓

**规则验证**:
- ✓ `analogThreshold = 190` 准确工作
- ✓ 过滤小幅度干扰

---

### 测试9: 移动平均滤波
**目标**: 验证5次读数平滑效果

**步骤**:
1. 观察代码中的滤波逻辑
2. 测试是否能过滤瞬时噪声

**预期结果**:
- 瞬时噪声被平滑
- 真实触摸能稳定触发

**规则验证**:
- ✓ `numReadings = 5` 移动平均
- ✓ 减少误触发

---

## 测试检查清单

- [ ] 测试1: 模拟输入基本触发
- [ ] 测试2: 全局去抖延迟（1000ms）
- [ ] 测试3: D3触摸检测
- [ ] 测试4: D3专用去抖延迟（3500ms）
- [ ] 测试5: D3状态稳定性检测
- [ ] 测试6: 全局互斥锁定
- [ ] 测试7: D3与模拟输入互斥
- [ ] 测试8: 阈值边界测试
- [ ] 测试9: 移动平均滤波

---

## 调试建议

### 启用调试输出
在第56-58行有D3调试代码（当前为空），可以添加：
```cpp
if (currentTime - lastD3DebugTime > 1000) {
  Serial.print("D3 State: ");
  Serial.println(currentTouchState);
  lastD3DebugTime = currentTime;
}
```

### 添加模拟值监控
在loop()中添加：
```cpp
static unsigned long lastDebugTime = 0;
if (currentTime - lastDebugTime > 500) {
  Serial.print("A0-A5: ");
  for (int i = 0; i < 6; i++) {
    Serial.print(total[i] / numReadings);
    Serial.print(" ");
  }
  Serial.println();
  lastDebugTime = currentTime;
}
```

---

## 预期问题与解决方案

### 问题1: D3频繁误触发
- **原因**: 环境噪声或接触不良
- **解决**: 增加 `touchStableThreshold` 或 `d3DebounceDelay`

### 问题2: 模拟输入不灵敏
- **原因**: 阈值过高
- **解决**: 降低 `analogThreshold` 值

### 问题3: 连续触发被阻止
- **原因**: 去抖延迟过长
- **解决**: 减小 `globalDebounceDelay` 或 `d3DebounceDelay`

---

## 测试工具

### 串口监视器设置
- 波特率: **9600**
- 换行符: 任意
- 观察输出: 1-7的数字

### 硬件需求
- Arduino开发板
- 6个模拟传感器（连接A0-A5）
- 1个数字触摸传感器（连接D3）
- USB数据线
